# Corrupter 3, for real this time.
# Notes: I pregenerated the randoms ahead of time and stored them in files. My runtime will likely be faster than yours
# and I provided the function for completeness' sake. I don't recommend generating the 10GB of random data into files though.

silent = False  # Set this to true if you don't want to see "= Starting Seed x =" 1000 times...

import random, struct
import multiprocessing
import time
# Creates random ints for the seed, with specified length.
# This function uses it's own random object, so it can be run across multiple threads without interference
def gen_rands(seed, mod):
    local_random = random.Random(seed)
    return [local_random.randrange(mod) for x in range(1000*10000)]


# Calls gen_rands but stores the output into a file. The result file is about 10MB as long as mod < 256
# Files are stored in a subdirectory called "randoms", which you'll need to create before using this.
def gen_rands_to_file(seed, mod):
    f = open("randoms/" + str(seed) + ".dat", "wb")
    f.write(bytearray(gen_rands(seed, mod)))


# Reads randoms from a file specified.
# If errors occur here then you probably don't have the randoms generated to files. You can either do that OR change the
# calls to this function to call get_rands instead. See the calls in question for details.
def get_rands_from_file(seed):
    with open("randoms/" + str(seed) + ".dat", "rb") as rand_file:
        return rand_file.read()


# Provided corrupter function, but modified to have a deterministic seed (useful for testing on test data)
def corrupt(contents, n, s):
    random.seed(s)
    B = contents
    B = list(B)
    for j in range(n):
        for i in range(10000):
            index = random.randrange(len(B))
            B[index] += (n - j)
            B[index] %= 256
    out = struct.pack("%dB" % len(B), *B)
    return out


# Given a list of 1000*10000 randoms generated by a seed, this will count the number of times the index 0, 1, 2, or 3 occurs.
# Optimization suggested by Shane Champion: We can reduce all totals mod 256
def count_occurances(rand_list):
    out = []
    for j in range(1000):
        zeros = 0
        ones = 0
        twos = 0
        threes = 0
        for i in range(10000):
            v = rand_list[(j*10000) + i]
            if(v == 0):
                zeros += 1
                zeros %= 256
            elif(v == 1):
                ones += 1
                ones %= 256
            elif(v == 2):
                twos += 1
                twos %= 256
            elif(v == 3):
                threes += 1
                threes %= 256
        out.append((j, zeros, ones, twos, threes))
    return out

# Decorrupter scan function. This only looks at the first 4 bytes of the content and checks that they are
# the zip file magic numbers 0x50 0x4B 0x03 0x04
# A call of this function scans all n for a provided seed, and does it incredibly quickly.
# If you don't want to read the randoms from a file, change get_rands_from_file(seed) to get_rands(seed, len(contents). It
# will be slower but you won't need a spare 10G of disk space
# This function returns a list of (n, seed) tuples that are potential matches.
def decorrupt_scan(contents, seed):
    out = []
    rolling_B = list(contents)

    hits = count_occurances(gen_rands(seed, len(contents))) # change this to get_rands_from_file(seed) if you pre-genned the randoms.

    for n in range(1, 1000):
        for j in range(n):
            # Optimization: There are 2 intertwined optimizations at work here. First: We don't compute (n - j) any more.
            # It's simpler if we just think about B[0].
            # Start with n = 1 and subtract from B[0] the number of times a 0 index occurs in the first 10000 randoms, which I'll call h0.
            # Consider n = 2. In the naive decorrupter we'll start with a clean B[0] and subtract h0. Then we'll loop again (via j) and
            # subtract h0 and h1. I.e for n = 2, we get B[0] - (2h0 + h1). Generalizing for a given n, we get B[0] - (nh0 + (n-1)h1 + ... 2h(n-2) + h(n-1))
            # Once we have that form, we can see that we can actually compute B[0] for n + 1 by simply subtracting h0, h1, h2 ... h(n-1), hn
            # This is the purpose of the rolling_B value
            rolling_B[0] -= hits[j][1]
            rolling_B[1] -= hits[j][2]
            rolling_B[2] -= hits[j][3]
            rolling_B[3] -= hits[j][4]
            if ((rolling_B[0] % 256) == 0x50) and ((rolling_B[1] % 256) == 0x4B) and ((rolling_B[2] % 256) == 0x03) and ((rolling_B[3] % 256) == 0x04):
                print("Candidate n and seed: n = " + str(n) + ", seed = " + str(seed))
                print("Decoding full file...")
                decorrupt_known(contents, n, seed)
                print("Done! Check " + str(n) + "_" + str(seed) + "_output.zip")
                out.append((n, seed))
    return out


# Decorrupts the contents with a given n and seed. Slow, it should only be used when you have a good candidate
# Writes the decoded output to a zip file
def decorrupt_known(contents, n, seed):
    B = list(contents)

    rands = gen_rands(seed, len(contents))  # change this to get_rands_from_file(seed) if you pre-genned the randoms.

    for j in range(n):
        k = (n - j)
        for i in range(10000):
            index = rands[(j * 10000) + i]
            B[index] -= k
    for i in range(len(B)):
        B[i] %= 256
    with open(str(n) + "_" + str(seed) + str("_output.zip"), "wb") as f:
        f.write(bytearray(B))


# Function called by each thread. data is a (seed, contents) tuple
def thread_start(data):
    if not silent:
        print("= Starting Seed " + str(data[0]) + " =")
    seed = data[0]
    contents = data[1]
    decorrupt_scan(contents, seed)


if __name__ == "__main__":
    filename = "output.zip"
    contents = open(filename, "rb").read()
    start = time.time()
    with multiprocessing.Pool(multiprocessing.cpu_count()) as pool:
        pool.map(thread_start, [(x, contents) for x in range(1000)])
    end = time.time()
    print("Elapsed time: " + str(int(end - start)) + "s")
    # Performance: This was run on a 12-core i7 8750H with the randoms stored on files on an NVME SSD. Obviously, results
    # may very, but all checks were completed on my test run in 8 minutes. Generating the randoms will probably add a while,
    # and I don't recommend storing them in files. I used it for my runs because I already had the files. I'd estimate a general
    # run time of 30 to 40 minutes.

    # Or if you just want to see the flag, execute the following code.
    #n = 234
    #seed = 84
    #decorrupt_known(contents, n, seed)